diff --git a/configure.ac b/configure.ac
index a7bf5eefae06..705b071c1f0c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -59,6 +59,7 @@ fi
 cat > local.exp <<EOF
 set CC_FOR_TARGET "$CC"
 set CXX_FOR_TARGET "$CXX"
+lappend boards_dir "$srcdir/../misc"
 EOF
 
 AM_MAINTAINER_MODE
@@ -261,6 +262,10 @@ case "$host" in
 	TARGET=POWERPC; TARGETDIR=powerpc
 	;;
 
+  riscv*-*-linux*)
+	TARGET=RISCV; TARGETDIR=riscv
+	;;
+
   s390-*-* | s390x-*-*)
 	TARGET=S390; TARGETDIR=s390
 	;;
diff --git a/misc/parse_tests.py b/misc/parse_tests.py
new file mode 100644
index 000000000000..ca4c95af6196
--- /dev/null
+++ b/misc/parse_tests.py
@@ -0,0 +1,50 @@
+#!/bin/python
+
+import sys
+
+def print_help():
+    print "Usage: python " + sys.argv[0] + " <test result file>"
+
+if len(sys.argv) != 2:
+    exit(1)
+
+summary = ""
+passed = []
+failed = []
+fname = sys.argv[1]
+f = open(fname, 'r')
+for l in f.readlines():
+    if l.startswith("PASS"):
+        z = l.split()
+        if not z[1] in passed:
+            passed.append(z[1])
+    elif l.startswith("FAIL"):
+        z = l.split()
+        if not z[1] in failed:
+            failed.append(z[1])
+    elif l.startswith("#"):
+        summary += l
+
+i = 0
+while i < len(passed):
+    if passed[i] in failed:
+        del passed[i]
+        continue
+    i += 1
+
+p_num = len(passed)
+f_num = len(failed)
+total = p_num + f_num
+
+print "---TEST FILES PASSED---"
+for t in passed: print t
+print
+print "---TEST FILES FAILED---"
+for t in failed: print t
+print
+print "------TEST SUMMARY------"
+print "Passed: " + str(p_num) + " (" + str(round(float(p_num)/total*100, 1)) + "%)"
+print "Failed: " + str(f_num) + " (" + str(round(float(f_num)/total*100, 1)) + "%)"
+print "Total:  " + str(total)
+print
+print summary
diff --git a/misc/riscv-sim.exp b/misc/riscv-sim.exp
new file mode 100644
index 000000000000..03177d2ca165
--- /dev/null
+++ b/misc/riscv-sim.exp
@@ -0,0 +1,6 @@
+load_generic_config "sim"
+set_board_info sim "spike pk"
+set_board_info compiler "[find_gcc]"
+set_board_info ldflags "-static"
+set_board_info gdb,nosignals 1
+set_board_info is_simulator 1
diff --git a/misc/run_test.sh b/misc/run_test.sh
new file mode 100755
index 000000000000..834d3cf24ab5
--- /dev/null
+++ b/misc/run_test.sh
@@ -0,0 +1,3 @@
+#/bin/bash
+riscv64-unknown-elf-gcc -g -I../../riscv64-unknown-elf/include -I../../riscv64-unknown-elf -L../../riscv64-unknown-elf/.libs/ $1 -lffi
+spike pk a.out
diff --git a/src/riscv/asm.py b/src/riscv/asm.py
new file mode 100644
index 000000000000..fe48a71b10da
--- /dev/null
+++ b/src/riscv/asm.py
@@ -0,0 +1,37 @@
+#!/bin/python
+
+def set_args_64(i):
+    return """
+####################
+## SET ARGUMENT """ + str(i) + """ ##
+####################
+
+set_arg""" + str(i) + """:
+    srli    t1, t0, FFI_FLAG_BITS_X""" + str(i) + """ # Shift to get the bits for this argument
+    andi    t1, t1, 3               # Mask out the bits for this argument
+
+    # when its zero, it means its just a word-sized int/ptr
+    bne     t1, zero, set_arg""" + str(i) + """_float
+    REG_L   a""" + str(i) + """, FFI_SIZEOF_ARG_X""" + str(i) + """(sp) # load argument
+    j       set_arg""" + str(i+1) + """
+
+set_arg""" + str(i) + """_float:
+    addi    t1, t1, -1
+
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg""" + str(i) + """_double
+    flw     fa""" + str(i) + """, FFI_SIZEOF_ARG_X""" + str(i) + """(sp) # load argument
+    j       set_arg""" + str(i+1) + """
+
+set_arg""" + str(i) + """_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa""" + str(i) + """, FFI_SIZEOF_ARG_X""" + str(i) + """(sp)
+"""
+
+def gen64_setargs_string():
+    setargs = ""
+    for i in range(8):
+        setargs += set_args_64(i)
+    return setargs
+
+print gen64_setargs_string()
diff --git a/src/riscv/ffi.c b/src/riscv/ffi.c
new file mode 100644
index 000000000000..77a744765827
--- /dev/null
+++ b/src/riscv/ffi.c
@@ -0,0 +1,1217 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2015 Michael Knyszek <mknyszek@berkeley.edu>
+                         2015 Andrew Waterman <waterman@cs.berkeley.edu>
+                         2017 Alon Amid <alonamid@eecs.berkeley.edu>
+   Based on MIPS N32/64 port
+
+   RISC-V Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <stdint.h>
+
+#define STACK_ARG_SIZE(x) FFI_ALIGN(x, FFI_SIZEOF_ARG)
+
+
+/* This function counts the number of floats and non-floats in a struct recursively.
+   We need this recursive function since there may be nested structs, and the struct ABI
+   is based on the assumption the structs are flatten to a flat hierarchy.
+   max_fp_reg_size is the maximum size of a floating point register (single precision or double precision) */
+static void struct_float_counter(unsigned int* num_struct_floats, unsigned int* num_struct_ints, ffi_type * p_arg, unsigned int max_fp_reg_size)
+{
+    ffi_type *e;
+    unsigned index = 0;
+    while ((e = (p_arg)->elements[index]))
+    {
+        if (e->type == FFI_TYPE_FLOAT && max_fp_reg_size >=32)
+        {
+            (*num_struct_floats)++;
+        }
+        else if (e->type == FFI_TYPE_DOUBLE && max_fp_reg_size >= 64)
+        {
+            (*num_struct_floats)++;
+        }
+        else if (e->type == FFI_TYPE_STRUCT)
+        {
+            struct_float_counter(num_struct_floats, num_struct_ints, e, max_fp_reg_size);
+        }
+        else
+        {
+            (*num_struct_ints)++;
+        }
+        index++;
+    }
+
+}
+
+
+/* This function takes in pointers to argument lists and locations, and places arguments from a flattened struct into appropriate
+  integer and floating point registers. */
+static void struct_args_to_regs(ffi_type * p_arg, char** argp, char** fargp, void ** p_argv, int* xreg, int* freg, unsigned int * a)
+{
+    ffi_type *e;
+    unsigned index = 0;
+    while ((e = (p_arg)->elements[index]))
+    {
+        if (e->type == FFI_TYPE_DOUBLE || e->type == FFI_TYPE_FLOAT)
+        {
+            if ((*a - 1) & (unsigned long) *argp)
+            {
+                *fargp = (char *) FFI_ALIGN(*fargp, *a);
+            }
+        }
+
+        *p_argv = (void*) FFI_ALIGN(*p_argv, e->alignment);
+
+        switch (e->type)
+        {
+            case FFI_TYPE_FLOAT:
+                *(float *) *fargp = *(float *)(* p_argv);
+                (*freg)++;
+                (*fargp) += FFI_SIZEOF_ARG;
+                break;
+
+            case FFI_TYPE_DOUBLE:
+                *(double *) *fargp = *(double *)(* p_argv);
+                (*freg)++;
+                (*fargp) += FFI_SIZEOF_ARG;
+                break;
+
+            case FFI_TYPE_SINT8:
+                *(ffi_arg *) *argp = *(SINT8 *)(* p_argv);
+                (*xreg)++;
+                (*argp) += FFI_SIZEOF_ARG;
+                break;
+
+            case FFI_TYPE_UINT8:
+                *(ffi_arg *) *argp = *(UINT8 *)(* p_argv);
+                (*xreg)++;
+                (*argp) += FFI_SIZEOF_ARG;
+                break;
+
+            case FFI_TYPE_SINT16:
+                *(ffi_arg *) *argp = *(SINT16 *)(* p_argv);
+                (*xreg)++;
+                (*argp) += FFI_SIZEOF_ARG;
+                break;
+
+            case FFI_TYPE_UINT16:
+                *(ffi_arg *) *argp = *(UINT16 *)(* p_argv);
+                (*xreg)++;
+                (*argp) += FFI_SIZEOF_ARG;
+                break;
+
+            case FFI_TYPE_SINT32:
+                *(ffi_arg *) *argp = *(SINT32 *)(* p_argv);
+                (*xreg)++;
+                (*argp) += FFI_SIZEOF_ARG;
+                break;
+
+            case FFI_TYPE_UINT32:
+                *(ffi_arg *) *argp = *(UINT32 *)(* p_argv);
+                (*xreg)++;
+                (*argp) += FFI_SIZEOF_ARG;
+                break;
+
+            case FFI_TYPE_SINT64:
+                *(ffi_arg *) *argp = *(SINT64 *)(* p_argv);
+                (*xreg)++;
+                (*argp) += FFI_SIZEOF_ARG;
+                break;
+
+            case FFI_TYPE_UINT64:
+                *(ffi_arg *) *argp = *(UINT64 *)(* p_argv);
+                (*xreg)++;
+                (*argp) += FFI_SIZEOF_ARG;
+                break;
+
+            case FFI_TYPE_STRUCT:
+               struct_args_to_regs(p_arg, argp, fargp, p_argv, xreg, freg, a);
+               break;
+
+            default:
+               break;
+         }
+         index++;
+         (*p_argv)+= e->size;
+    }
+}
+
+
+
+/* ffi_prep_args is called by the assembly routine once stack space
+   has been allocated for the function's arguments */
+static void ffi_prep_args(char *stack, extended_cif *ecif, int bytes, int flags)
+{
+    int i;
+    void **p_argv;
+    char *argp, *fargp, *cpy_struct, *arg_stack_start;
+    ffi_type **p_arg;
+
+    ffi_cif* wcif = ecif->cif; //working cif
+    char isvariadic = wcif->isvariadic;
+    int nfixedargs = wcif->nfixedargs;
+
+    //max_fp_reg_size is the maximim size of a floating point register, depending if the ABI defined it as single precision (32) or double precision (64)
+    //This can be expanded to 128 bits for QUAD precision if needs
+    int max_fp_reg_size = (wcif->abi == FFI_RV64_DOUBLE || wcif->abi == FFI_RV32_DOUBLE) ? 64 :
+                             ((wcif->abi == FFI_RV64_SOFT_FLOAT || wcif->abi == FFI_RV32_SOFT_FLOAT) ? 0 : 32);
+
+    //counters for used integer and floating point registers
+    int xreg = 0;
+    int freg = 0;
+
+
+    fargp = stack;
+    if (max_fp_reg_size != 0)
+    {
+      argp = stack + (8* FFI_SIZEOF_ARG);
+      arg_stack_start = stack + (16 * FFI_SIZEOF_ARG); //set the "fake stack" space for arguments that are going to be passed through registers
+    }
+    else
+    {
+        argp = stack;
+        arg_stack_start = stack + (8 * FFI_SIZEOF_ARG); //set the "fake stack" space for arguments that are going to be passed through registers
+    }
+    cpy_struct = stack + FFI_ALIGN(bytes, 16);
+
+    memset(stack, 0, bytes);
+
+    if (wcif->rstruct_flag != 0)
+    {
+        *(ffi_arg *) argp = (ffi_arg) ecif->rvalue;
+        argp += sizeof(ffi_arg);
+        xreg++;
+    }
+
+    p_argv = ecif->avalue;
+
+    for (i = 0, p_arg = wcif->arg_types; i < wcif->nargs; i++, p_arg++)
+    {
+        size_t z;
+        unsigned int a;
+	unsigned int num_struct_floats = 0;
+        unsigned int num_struct_ints = 0;
+
+
+        /* Align if necessary. */
+        a = (*p_arg)->alignment;
+        if (a < sizeof(ffi_arg))
+            a = sizeof(ffi_arg);
+
+        int type = (*p_arg)->type;
+
+
+        if (type == FFI_TYPE_STRUCT)
+        {
+            struct_float_counter(&num_struct_floats, &num_struct_ints, *p_arg, max_fp_reg_size);
+        }
+
+
+        z = (*p_arg)->size;
+        if (z <= sizeof(ffi_arg) && (freg < 8 || xreg <8))
+        {
+            int type = (*p_arg)->type;
+            z = sizeof(ffi_arg);
+
+            /* The size of a pointer depends on the ABI */
+            if (type == FFI_TYPE_POINTER)
+            #if _riscv_xlen == 64
+                type = FFI_TYPE_SINT64;
+            #else
+                type = FFI_TYPE_SINT32;
+            #endif
+
+
+
+            /* Handle float argument types for soft float case */
+            if (xreg<8 && ((max_fp_reg_size < 32) || freg>7 || (isvariadic && i>=nfixedargs)))
+            {
+                switch (type)
+                {
+                    case FFI_TYPE_FLOAT:
+                        type = FFI_TYPE_UINT32;
+                        break;
+                    default:
+                        break;
+                }
+            }
+
+
+            /* Handle double argument types for single precision soft case */
+            if (xreg<8 && ((max_fp_reg_size < 64) || freg>7 || (isvariadic && i>=nfixedargs)))
+            {
+                switch (type)
+                {
+                    case FFI_TYPE_DOUBLE:
+                        type = FFI_TYPE_UINT64;
+                        break;
+                    default:
+                        break;
+                }
+            }
+
+
+            /* Handle float argument types into single registers */
+            if (freg<8 && (type == FFI_TYPE_FLOAT || type == FFI_TYPE_DOUBLE || num_struct_floats>0) && !(isvariadic && i>=nfixedargs))
+            {
+              //if this is a floating point, we want to align the floating point "fake stack"
+              if ((a - 1) & (unsigned long) fargp)
+              {
+                  fargp = (char *) FFI_ALIGN(fargp, a);
+              }
+
+              switch (type)
+              {
+                /* This can only happen with 64bit slots. */
+                case FFI_TYPE_FLOAT:
+                    *(float *) fargp = *(float *)(* p_argv);
+                    if (freg < 8) {freg++; fargp += FFI_SIZEOF_ARG;}
+                    break;
+
+                case FFI_TYPE_DOUBLE:
+                    *(double *) fargp = *(double *)(* p_argv);
+                    if (freg < 8) {freg++; fargp += FFI_SIZEOF_ARG;}
+                    break;
+                /* Handle structures with floating point elements */
+                default:
+                    if (type == FFI_TYPE_STRUCT && num_struct_floats==1)
+                    {
+                        struct_args_to_regs(*p_arg, &argp, &fargp, p_argv, &xreg, &freg, &a);
+                    }
+                    else if (type == FFI_TYPE_STRUCT && (num_struct_floats == 2) && (max_fp_reg_size != 0) && freg<7)
+                    {
+                        struct_args_to_regs(*p_arg, &argp, &fargp, p_argv, &xreg, &freg, &a);
+                    }
+                    else if (type == FFI_TYPE_STRUCT && (num_struct_floats == 1) && (num_struct_ints == 1) && (max_fp_reg_size != 0) && freg<8 && xreg<8)
+                    {
+                        struct_args_to_regs(*p_arg, &argp, &fargp, p_argv, &xreg, &freg, &a);
+                    }
+                    break;
+              }
+            }
+            else //handle like an integer
+            {
+              if ((a - 1) & (unsigned long) argp)
+              {
+                  argp = (char *) FFI_ALIGN(argp, a);
+              }
+              switch (type)
+              {
+                case FFI_TYPE_SINT8:
+                    *(ffi_arg *)argp = *(SINT8 *)(* p_argv);
+                    if (xreg<8) xreg++;
+                    break;
+
+                case FFI_TYPE_UINT8:
+                    *(ffi_arg *)argp = *(UINT8 *)(* p_argv);
+                    if (xreg<8) xreg++;
+                    break;
+
+                case FFI_TYPE_SINT16:
+                    *(ffi_arg *)argp = *(SINT16 *)(* p_argv);
+                    if (xreg<8) xreg++;
+                    break;
+
+                case FFI_TYPE_UINT16:
+                    *(ffi_arg *)argp = *(UINT16 *)(* p_argv);
+                    if (xreg<8) xreg++;
+                    break;
+
+                case FFI_TYPE_SINT32:
+                    *(ffi_arg *)argp = *(SINT32 *)(* p_argv);
+                    if (xreg<8) xreg++;
+                    break;
+
+                case FFI_TYPE_UINT32:
+                    *(ffi_arg *)argp = *(UINT32 *)(* p_argv);
+                    if (xreg<8) xreg++;
+                    break;
+
+                case FFI_TYPE_SINT64:
+                    *(ffi_arg *)argp = *(SINT64 *)(* p_argv);
+                    if (xreg<8) xreg++;
+                    break;
+
+                case FFI_TYPE_UINT64:
+                    *(ffi_arg *)argp = *(UINT64 *)(* p_argv);
+                    if (xreg<8) xreg++;
+                    break;
+                /* Handle structures. */
+                default:
+                    memcpy(argp, *p_argv, (*p_arg)->size);
+                    if (xreg<8) xreg++;
+                    break;
+               }
+               argp += z;
+            }
+        }
+        else if (z <= 2*sizeof(ffi_arg) && (freg < 8 || xreg <8))
+        {
+            if (type == FFI_TYPE_STRUCT && (num_struct_floats == 2) && (num_struct_ints==0) && (max_fp_reg_size != 0) && freg<7)
+            {
+               struct_args_to_regs(*p_arg, &argp, &fargp, p_argv, &xreg, &freg, &a);
+            }
+
+            else if (type == FFI_TYPE_STRUCT && (num_struct_floats == 1) && (num_struct_ints == 1) && (max_fp_reg_size != 0) && freg<8 && xreg<8)
+            {
+               struct_args_to_regs(*p_arg, &argp, &fargp, p_argv, &xreg, &freg, &a);
+            }
+            else //handle like the integer convention
+            {
+               if (isvariadic && i>=nfixedargs && xreg<8 && a==2*FFI_SIZEOF_ARG && (xreg%2)==1)
+               {
+                  xreg += 1;
+                  argp += FFI_SIZEOF_ARG;
+               }
+                /* Check if the data will fit within the register space.
+                   Handle it if it doesn't. */
+                unsigned long end = (unsigned long) argp + z;
+                unsigned long cap = (unsigned long) arg_stack_start;
+                if (end <= cap) //still storing in register space
+                {
+                    memcpy(argp, *p_argv, z);
+                    int temp_num_args = (z + FFI_SIZEOF_ARG - 1) / FFI_SIZEOF_ARG; //ceiling of number of integer regs
+                    xreg += temp_num_args;
+                    argp += temp_num_args * FFI_SIZEOF_ARG;
+                }
+                else if ((unsigned long)argp > cap) //we're already storing on the stack
+                {
+                    if ((a - 1) & (unsigned long) argp)
+                    {
+                        argp = (char *) FFI_ALIGN(argp, a);
+                    }
+
+                    memcpy(argp, *p_argv, z);
+                    argp += z;
+                }
+                else //need to store partially in register space and partially on the stack
+                {
+                    unsigned long portion = cap - (unsigned long)argp;
+                    memcpy(argp, *p_argv, portion);
+                    xreg += (portion + FFI_SIZEOF_ARG - 1) / FFI_SIZEOF_ARG; //ceiling of number of integer regs
+                    argp = arg_stack_start;
+                    z -= portion;
+                    memcpy(argp, (void*)((unsigned long)(*p_argv) + portion), z);
+                    argp += z;
+                }
+            }
+        }
+        else if(xreg < 8 && z > 2*sizeof(ffi_arg))
+        {
+            /* It's too big to pass in any registers or on the stack,
+               so we pass a pointer, and copy the struct to pass by value.
+               But, we can't _just_ copy it onto the stack! We need to actually
+               make sure it gets onto the "bottom" (really the top, high memory
+               addresses) of the stack frame... */
+            /* Update pointer to where our struct location on the stack is */
+            cpy_struct -= FFI_ALIGN(z, a);
+
+            memcpy(cpy_struct, *p_argv, z);
+
+            /* Pass pointer in register */
+            *(ffi_arg *)argp = (ffi_arg) cpy_struct;
+            xreg++;
+            z = sizeof(ffi_arg);
+            argp += FFI_SIZEOF_ARG;
+        }
+        else
+        {
+            /* Just some big struct, pass it by value by copying it onto
+               the stack. */
+            argp = (char *) FFI_ALIGN(argp, a);
+            memcpy(argp, *p_argv, z);
+            argp += z;
+        }
+        p_argv++;
+    }
+}
+
+
+
+
+/*calculate and update the overall size in bytes in register
+   of a struct that is passed through registers
+   This is done recursively to handle the case of nested structs. */
+static void riscv_struct_bytes(unsigned int* fbytes, unsigned int* bytes, ffi_type *s_arg)
+{
+    ffi_type *e;
+    unsigned struct_index = 0;
+    while ((e = s_arg->elements[struct_index]))
+    {
+        if (e->type == FFI_TYPE_DOUBLE || e->type == FFI_TYPE_FLOAT)
+        {
+            if ((e->alignment - 1) & *fbytes)
+            {
+                *fbytes = (unsigned)FFI_ALIGN(*fbytes, e->alignment);
+            }
+            *fbytes += STACK_ARG_SIZE(e->size);
+        }
+        else if (e->type == FFI_TYPE_STRUCT)
+        {
+            riscv_struct_bytes(fbytes, bytes,e);
+        }
+        else
+        {
+            /* Add any padding if necessary */
+            if ((e->alignment - 1) & *bytes)
+            {
+                *bytes = (unsigned)FFI_ALIGN(*bytes, e->alignment);
+            }
+            *bytes += STACK_ARG_SIZE(e->size);
+        }
+        struct_index++;
+    }
+
+}
+
+
+/* calculate and update the flags of a struct that is passed through registers
+   This is done recursively to handle the case of nested structs. */
+static void riscv_struct_flags(unsigned int* farg_reg, unsigned int* xarg_reg, unsigned int* temp_float_flags, unsigned int* temp_int_flags, ffi_type *s_arg, unsigned int max_fp_reg_size)
+{
+    int struct_index=0;
+    ffi_type *e;
+    while ((e = s_arg->elements[struct_index]))
+    {
+        if (e->type == FFI_TYPE_DOUBLE && max_fp_reg_size >= 64)
+        {
+            *temp_float_flags += 1 << (*farg_reg);
+            (*farg_reg)++;
+        }
+        else if (e->type == FFI_TYPE_FLOAT && max_fp_reg_size >= 32)
+        {
+            *temp_float_flags += 0 << (*farg_reg);
+            (*farg_reg)++;
+        }
+        else if (e->type == FFI_TYPE_STRUCT)
+        {
+            riscv_struct_flags(farg_reg, xarg_reg, temp_float_flags, temp_int_flags, e, max_fp_reg_size);
+        }
+        else
+        {
+            *temp_int_flags += 0 << (*xarg_reg);
+            (*xarg_reg)++;
+        }
+        struct_index++;
+    }
+}
+
+
+/* The recursive function call to determine the flags for a return value
+   which is a struct.
+   Requires recursive function since ABI assumes struct hierarchies are flattened */
+static unsigned riscv_return_struct_flags_rec(ffi_type *arg, unsigned flags)
+{
+    unsigned int index = 0;
+    ffi_type *e;
+
+
+    while ((e = arg->elements[index]))
+    {
+        if (e->type == FFI_TYPE_DOUBLE)
+            flags += FFI_TYPE_DOUBLE << (index*FFI_FLAG_BITS);
+        else if (e->type == FFI_TYPE_FLOAT)
+            flags += FFI_TYPE_FLOAT << (index*FFI_FLAG_BITS);
+        else if (e->type == FFI_TYPE_STRUCT)
+            flags += riscv_return_struct_flags_rec(e, flags) << (index*FFI_FLAG_BITS);
+        else
+            flags += FFI_TYPE_INT << (index*FFI_FLAG_BITS);
+        index++;
+    }
+    return flags;
+}
+
+
+/* Function to determine the flags for a return value which is a struct */
+static unsigned riscv_return_struct_flags(int max_fp_reg_size, ffi_type *arg)
+{
+    unsigned flags = 0;
+    unsigned small = FFI_TYPE_SMALLSTRUCT;
+
+    /* Returning structures under n32 is a tricky thing.
+       A struct with only one or two floating point fields
+       is returned in $f0 (and $f2 if necessary). Any other
+       struct results at most 128 bits are returned in $2
+       (the first 64 bits) and $3 (remainder, if necessary).
+       Larger structs are handled normally. */
+
+    if (arg->size > 2 * FFI_SIZEOF_ARG)
+        return 0;
+
+    if (arg->size > FFI_SIZEOF_ARG)
+        small = FFI_TYPE_SMALLSTRUCT2;
+
+
+    unsigned int num_struct_floats =0;
+    unsigned int num_struct_ints =0;
+    struct_float_counter(&num_struct_floats, &num_struct_ints, arg, max_fp_reg_size);
+    if ((num_struct_floats==1) && (num_struct_ints ==0) && (max_fp_reg_size !=0))
+    {
+        flags = riscv_return_struct_flags_rec(arg, flags);
+    }
+    else if (num_struct_floats == 2 && (num_struct_ints==0) && (max_fp_reg_size != 0))
+    {
+        flags = riscv_return_struct_flags_rec(arg, flags);
+    }
+    else if ((num_struct_floats == 1) && (num_struct_ints == 1) && (max_fp_reg_size != 0))
+    {
+        flags = riscv_return_struct_flags_rec(arg, flags);
+    }
+    else //if (flags && (num_struct_floats > 2 || num_struct_ints > 2))
+    {
+        /* There are three arguments and the first two are
+               floats! This must be passed the old way. */
+        return small;
+    }
+
+    if (max_fp_reg_size ==0)
+        flags += FFI_TYPE_STRUCT_SOFT;
+
+    if (!flags)
+        return small;
+
+    return flags;
+}
+
+
+
+/* Generate the flags word for processing arguments and
+   putting them into their proper registers in the
+   assembly routine. */
+
+void ffi_prep_cif_machdep_flags(ffi_cif *cif, unsigned int isvariadic, unsigned int nfixedargs)
+{
+    int type;
+    unsigned xarg_reg = 0;
+    unsigned farg_reg = 0;
+    unsigned temp_float_flags =0;
+    unsigned temp_int_flags= 0;
+    unsigned index = 0;
+
+    unsigned int struct_flags = 0;
+    unsigned int max_fp_reg_size = (cif->abi == FFI_RV64_DOUBLE || cif->abi == FFI_RV32_DOUBLE) ? 64 :
+                             ((cif->abi == FFI_RV64_SOFT_FLOAT || cif->abi == FFI_RV32_SOFT_FLOAT) ? 0 : 32);
+    //this can be expanded to 128 for QUAD if needed
+
+    cif->flags = 0;
+
+    if (cif->rtype->type == FFI_TYPE_STRUCT)
+    {
+        struct_flags = riscv_return_struct_flags(max_fp_reg_size, cif->rtype);
+        if (struct_flags == 0)
+        {
+            /* This means that the structure is being passed as
+               a hidden argument */
+            xarg_reg = 1;
+            cif->rstruct_flag = !0;
+        }
+        else
+            cif->rstruct_flag = 0;
+    }
+    else
+        cif->rstruct_flag = 0;
+
+
+    /* Set the first 8 integer and first 8 floating point  existing argument types in the flag bit string
+     *
+     * We describe the two argument types we care about:
+     * - Whether or not its a float/double
+     * - Whether or not its a struct
+     *
+     * For the function arguments, each of the first 16 bits of cif->flags represents 1 argument
+     * The first 8 bits represent the 8 floating point registers.
+     * a '0' means the argument is a float, while a '1' means the argument is a double.
+     * The next 8 bits represent the 8 integer register. They are currently all 0, but have
+     * potential for differentiation
+     *
+     * The last 16 bits are just used to describe the return type
+     * The return type uses complex 2-bit flags, which are described in ffitarget.h
+     *
+     * FFI_FLAG_BITS = 2
+     */
+    while ((xarg_reg<8 || farg_reg<8) && index < cif->nargs)
+    {
+        type = (cif->arg_types)[index]->type;
+        switch (type)
+        {
+            case FFI_TYPE_FLOAT:  /* float_flag = 0 */
+                if (farg_reg < 8 && max_fp_reg_size >= 32 && !(isvariadic && xarg_reg >= nfixedargs))
+                {
+                    temp_float_flags += 0 << (farg_reg);
+                    farg_reg++;
+                }
+                else if (xarg_reg < 8)
+                {
+                    temp_int_flags += 0 << (xarg_reg);
+                    xarg_reg++;
+                }
+                break;
+            case FFI_TYPE_DOUBLE: /* float_flag = 1 */
+                if (farg_reg < 8 && max_fp_reg_size >= 64 && !(isvariadic && xarg_reg >= nfixedargs))
+                {
+                    temp_float_flags += 1 << (farg_reg);
+                    farg_reg++;
+                }
+                else if (xarg_reg < 8)
+                {
+                    temp_int_flags += 0 << (xarg_reg);
+                    xarg_reg++;
+                }
+                break;
+            case FFI_TYPE_LONGDOUBLE: /* goes in integer registers */
+                if (xarg_reg < 7)
+                {
+                    temp_int_flags += 0 << (xarg_reg+1);
+                    xarg_reg+=2;
+                }
+                else if (xarg_reg < 8)
+                {
+                    temp_int_flags += 0 << (xarg_reg);
+                    xarg_reg++;
+                }
+                break;
+            case FFI_TYPE_STRUCT:
+                if(((cif->arg_types)[index]->size > 2 * FFI_SIZEOF_ARG) && xarg_reg < 8)
+                /* The struct is too big to pass on the stack, so we pass it by reference */
+                {
+                    (xarg_reg)++;
+                }
+                else if ((max_fp_reg_size == 0) && xarg_reg < 8)
+                {
+                    int temp_num_regs = ((cif->arg_types)[index]->size + 1 / FFI_SIZEOF_ARG);
+                    xarg_reg += (xarg_reg + temp_num_regs < 8) ? temp_num_regs : (8-xarg_reg);
+                }
+                else //we might have floating points in the struct
+                {
+                    unsigned num_struct_floats=0;
+                    unsigned num_struct_ints=0;
+
+                    struct_float_counter(&num_struct_floats, &num_struct_ints, cif->arg_types[index], max_fp_reg_size);
+                    if (num_struct_floats == 2 && num_struct_ints ==0 && farg_reg < 7)
+                    {
+                        riscv_struct_flags(&farg_reg, &xarg_reg, &temp_float_flags, &temp_int_flags,cif->arg_types[index], max_fp_reg_size);
+                    }
+                    else if (num_struct_floats == 1 && num_struct_ints==1 && xarg_reg < 8 && farg_reg < 8)
+                    {
+                        riscv_struct_flags(&farg_reg, &xarg_reg, &temp_float_flags, &temp_int_flags,cif->arg_types[index], max_fp_reg_size);
+                    }
+                    else if (xarg_reg < 8)
+                    {
+                        int temp_num_regs = ((cif->arg_types)[index]->size + 1 / FFI_SIZEOF_ARG);
+                        xarg_reg += (xarg_reg + temp_num_regs < 8) ? temp_num_regs : (8-xarg_reg);
+                    }
+               }
+        }
+        index++;
+    }
+
+    cif->flags += temp_int_flags << 8 ;
+    cif->flags += temp_float_flags;
+
+    /* Set the return type flag */
+
+    type = cif->rtype->type;
+
+    /* Handle float return types for soft float case */
+    if (max_fp_reg_size < 32 && type == FFI_TYPE_FLOAT)
+    {
+        type = FFI_TYPE_UINT32;
+    }
+
+    if (max_fp_reg_size < 64 && type == FFI_TYPE_DOUBLE)
+    {
+        type = FFI_TYPE_UINT64;
+    }
+
+    switch (type)
+    {
+        case FFI_TYPE_STRUCT:
+            if (struct_flags != 0)
+            {
+                /* The structure is returned via some tricky mechanism */
+                cif->flags += FFI_TYPE_STRUCT << (FFI_FLAG_BITS * 8);
+                cif->flags += struct_flags << (4 + (FFI_FLAG_BITS * 8));
+            }
+            /* else the structure is returned through a hidden
+               first argument. Do nothing, 'cause FFI_TYPE_VOID is 0 */
+            break;
+        case FFI_TYPE_VOID:
+            /* Do nothing, 'cause FFI_TYPE_VOID is 0 */
+            break;
+        case FFI_TYPE_FLOAT:
+        case FFI_TYPE_DOUBLE:
+        case FFI_TYPE_LONGDOUBLE:
+            cif->flags += cif->rtype->type << (FFI_FLAG_BITS * 8);
+            break;
+        case FFI_TYPE_SINT32:
+        case FFI_TYPE_UINT32:
+            cif->flags += FFI_TYPE_SINT32 << (FFI_FLAG_BITS * 8);
+            break;
+        default:
+            cif->flags += FFI_TYPE_INT << (FFI_FLAG_BITS * 8);
+            break;
+    }
+}
+
+/* Count how big our argspace is in bytes. Here, we always
+   allocate at least 8 pointer words and handle big structs
+   being passed in registers. */
+
+void ffi_prep_cif_machdep_bytes(ffi_cif *cif)
+{
+    int i;
+    ffi_type **ptr;
+    unsigned bytes = 0, fbytes =0, extra_bytes = 0;
+
+    unsigned int max_fp_reg_size = (cif->abi == FFI_RV64_DOUBLE || cif->abi == FFI_RV32_DOUBLE) ? 64 :
+                             ((cif->abi == FFI_RV64_SOFT_FLOAT || cif->abi == FFI_RV32_SOFT_FLOAT) ? 0 : 32);
+
+    if (cif->rtype->type == FFI_TYPE_STRUCT)
+        bytes = STACK_ARG_SIZE(sizeof(void*));
+
+    for (ptr = cif->arg_types, i = 0; i < cif->nargs; i++, ptr++)
+    {
+        unsigned type = (cif->arg_types)[i]->type;
+        /* When we pass big structs in registers, we copy it onto the stack and assign a pointer to it */
+        if ((*ptr)->size > 2 * FFI_SIZEOF_ARG && bytes < 8 * FFI_SIZEOF_ARG)
+        {
+            bytes += sizeof(void*);
+            extra_bytes += STACK_ARG_SIZE((*ptr)->size);
+        }
+        else
+        {
+            if (type == FFI_TYPE_FLOAT || type == FFI_TYPE_DOUBLE)
+            {
+                if (((*ptr)->alignment - 1) & fbytes)
+                {
+                   fbytes = (unsigned)FFI_ALIGN(fbytes, (*ptr)->alignment);
+                }
+                fbytes += STACK_ARG_SIZE((*ptr)->size);
+            }
+            else if (type == FFI_TYPE_STRUCT) //This struct must have a size of less than 2XLEN
+            {
+                riscv_struct_bytes(&fbytes, &bytes, cif->arg_types[i]);
+            }
+            else
+            {
+                if (((*ptr)->alignment - 1) & bytes)
+                {
+                   bytes = (unsigned)FFI_ALIGN(bytes, (*ptr)->alignment);
+                }
+                bytes += STACK_ARG_SIZE((*ptr)->size);
+            }
+        }
+    }
+
+
+    if (max_fp_reg_size != 0)
+    {
+        if (fbytes < 8 * FFI_SIZEOF_ARG)
+        {
+            fbytes = 8 * FFI_SIZEOF_ARG;
+        }
+    }
+    if (bytes < 8 * FFI_SIZEOF_ARG)
+        bytes = 8 * FFI_SIZEOF_ARG;
+
+    bytes += fbytes;
+    bytes += extra_bytes;
+
+    cif->bytes = bytes;
+}
+
+/* Perform machine dependent cif processing */
+
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif)
+{
+    ffi_prep_cif_machdep_bytes(cif);
+    ffi_prep_cif_machdep_flags(cif, 0, 0);
+    cif->isvariadic = 0;
+    return FFI_OK;
+}
+
+/* Perform machine dependent cif processing when we have a variadic function */
+
+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs, unsigned int ntotalargs)
+{
+    ffi_prep_cif_machdep_bytes(cif);
+    ffi_prep_cif_machdep_flags(cif, 1, nfixedargs);
+    cif->isvariadic = 1;
+    cif->nfixedargs = nfixedargs;
+    return FFI_OK;
+}
+
+/* Low level routine for calling RV64 functions */
+extern int ffi_call_asm(void (*)(char *, extended_cif *, int, int),
+                         extended_cif *, unsigned, unsigned,
+                         unsigned *, void (*)(void))
+                         __attribute__((visibility("hidden")));
+
+void ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+{
+    extended_cif ecif;
+
+    ecif.cif = cif;
+    ecif.avalue = avalue;
+
+    /* If the return value is a struct and we don't have a return	*/
+    /* value address then we need to make one		                */
+
+    if ((rvalue == NULL) && (cif->rtype->type == FFI_TYPE_STRUCT))
+        ecif.rvalue = alloca(cif->rtype->size);
+    else
+        ecif.rvalue = rvalue;
+
+    ffi_call_asm(ffi_prep_args, &ecif, cif->bytes, cif->flags, ecif.rvalue, fn);
+}
+
+#if FFI_CLOSURES
+
+extern void ffi_closure_asm(void) __attribute__((visibility("hidden")));
+
+ffi_status ffi_prep_closure_loc(ffi_closure *closure, ffi_cif *cif, void (*fun)(ffi_cif*,void*,void**,void*), void *user_data, void *codeloc)
+{
+    unsigned int *tramp = (unsigned int *) &closure->tramp[0];
+
+    uintptr_t fn = (uintptr_t) ffi_closure_asm;
+    FFI_ASSERT(tramp == codeloc);
+
+    /* Remove when more than just rv64 is supported */
+    if (!(cif->abi == FFI_RV64_SINGLE || cif->abi == FFI_RV64_DOUBLE))
+    {
+       return FFI_BAD_ABI;
+    }
+
+    if (cif->abi == FFI_RV32_SINGLE || cif->abi == FFI_RV32_DOUBLE || cif->abi == FFI_RV32_SOFT_FLOAT || fn < 0x7ffff000U)
+    {
+        /* auipc t0, 0 (i.e. t0 <- codeloc) */
+        tramp[0] = 0x00000297;
+        /* lui t1, %hi(fn) */
+        tramp[1] = 0x00000337 | ((fn + 0x800) & 0xFFFFF000);
+        /* jalr x0, t1, %lo(fn) */
+        tramp[2] = 0x00030067 | ((fn & 0xFFF) << 20);
+        /* nops */
+        tramp[3] = 0x00000013;
+        tramp[4] = 0x00000013;
+        tramp[5] = 0x00000013;
+    }
+    else
+    {
+        /* auipc t0, 0 (i.e. t0 <- codeloc) */
+        tramp[0] = 0x00000297;
+        /* ld t1, 16(t0) */
+        tramp[1] = 0x0102b303;
+        /* jalr x0, t1, %lo(fn) */
+        tramp[2] = 0x00030067;
+        /* nop */
+        tramp[3] = 0x00000013;
+        /* fn */
+        tramp[4] = fn;
+        tramp[5] = fn >> 32;
+    }
+
+    closure->cif = cif;
+    closure->fun = fun;
+    closure->user_data = user_data;
+    __builtin___clear_cache(codeloc, codeloc + FFI_TRAMPOLINE_SIZE);
+
+    return FFI_OK;
+}
+
+static void copy_struct(char *target, unsigned offset, ffi_abi abi, ffi_type *type, int* argn, int* fargn, unsigned arg_offset, ffi_arg *ar, ffi_arg *fpr, int max_fp_reg_size)
+{
+    ffi_type **elt_typep = type->elements;
+    unsigned o;
+    char *tp;
+    char *argp;
+    char *fpp;
+    unsigned int num_struct_floats=0;
+    unsigned int num_struct_ints=0;
+    struct_float_counter(&num_struct_floats, &num_struct_ints, type, max_fp_reg_size);
+    if ((num_struct_floats ==2 && num_struct_ints==0 && *fargn < 7) ||
+            (num_struct_floats ==1 && num_struct_ints==1 && *argn<8 && *fargn<8) ||
+            (num_struct_floats ==1 && num_struct_ints==0 && *fargn<8))
+    {
+        while(*elt_typep)
+        {
+            ffi_type *elt_type = *elt_typep;
+            o = FFI_ALIGN(offset, elt_type->alignment);
+            arg_offset += o - offset;
+            offset = o;
+            tp = target + offset;
+            fpp = (char *) (fpr + *fargn);
+            argp = (char *)(ar + *argn);
+            if (elt_type->type == FFI_TYPE_FLOAT && (max_fp_reg_size != 0))
+            {
+                *(float *)tp = *(float *)fpp;
+                (*fargn)++;
+                offset += elt_type->size;
+            }
+            else if (elt_type->type == FFI_TYPE_DOUBLE && (max_fp_reg_size !=0))
+            {
+                 *(double *)tp = *(double *)fpp;
+                 (*fargn)++;
+                offset += elt_type->size;
+            }
+            else if (elt_type->type == FFI_TYPE_STRUCT && (max_fp_reg_size !=0))
+            {
+                 copy_struct(tp, offset, abi, elt_type, argn, fargn, arg_offset, ar, fpr, max_fp_reg_size);
+            }
+            else
+            {
+                memcpy(tp, argp + arg_offset, elt_type->size);
+                offset += elt_type->size;
+                arg_offset += elt_type->size;
+                *argn += arg_offset / sizeof(ffi_arg);
+                arg_offset = arg_offset % sizeof(ffi_arg);
+            }
+            elt_typep++;
+        }
+        *argn = arg_offset > 0 ? (*argn)+1 : *argn;
+    }
+    else
+    {
+        while(*elt_typep)
+        {
+            ffi_type *elt_type = *elt_typep;
+            o = FFI_ALIGN(offset, elt_type->alignment);
+            arg_offset += o - offset;
+            offset = o;
+            tp = target + offset;
+            *argn += arg_offset / sizeof(ffi_arg);
+            arg_offset = arg_offset % sizeof(ffi_arg);
+            argp = (char *)(ar + *argn);
+
+            if (elt_type->type == FFI_TYPE_STRUCT)
+            {
+                 copy_struct(tp, offset, abi, elt_type, argn, fargn, arg_offset, ar, fpr, max_fp_reg_size);
+                 offset += elt_type->size;
+            }
+            else
+            {
+                memcpy(tp, argp + arg_offset, elt_type->size);
+                offset += elt_type->size;
+                arg_offset += elt_type->size;
+                *argn += arg_offset / sizeof(ffi_arg);
+                arg_offset = arg_offset % sizeof(ffi_arg);
+            }
+            elt_typep++;
+        }
+        *argn = arg_offset > 0 ? (*argn)+1 : *argn;
+    }
+}
+
+
+/*
+* Decodes the arguments to a function, which will be stored on the
+* stack. AR is the pointer to the beginning of the integer
+* arguments. FPR is a pointer to the area where floating point
+* registers have been saved.
+*
+* RVALUE is the location where the function return value will be
+* stored. CLOSURE is the prepared closure to invoke.
+*
+* This function should only be called from assembly, which is in
+* turn called from a trampoline.
+*
+* Returns the function return flags.
+*
+*/
+int ffi_closure_riscv_inner(ffi_closure *closure, void *rvalue, ffi_arg *ar, ffi_arg *fpr)
+{
+    ffi_cif *cif;
+    void **avaluep;
+    ffi_arg *avalue;
+    ffi_type **arg_types;
+    int i, avn, argn, fargn;
+    int argn_struct;
+    ffi_arg *argp;
+    ffi_arg *fargp;
+    size_t z;
+
+    cif = closure->cif;
+    unsigned int max_fp_reg_size = (cif->abi == FFI_RV64_DOUBLE || cif->abi == FFI_RV32_DOUBLE) ? 64 :
+                             ((cif->abi == FFI_RV64_SOFT_FLOAT || cif->abi == FFI_RV32_SOFT_FLOAT) ? 0 : 32);
+    //this can be expanded to 128 for QUAD if needed
+
+
+    avalue = alloca(cif->nargs * sizeof (ffi_arg));
+    avaluep = alloca(cif->nargs * sizeof (ffi_arg));
+    argn = 0;
+    fargn = 0;
+
+    if (cif->rstruct_flag)
+    {
+        rvalue = (void *)ar[0];
+        argn = 1;
+    }
+
+    argp = ar + argn;
+    i = 0;
+    avn = cif->nargs;
+    arg_types = cif->arg_types;
+
+    while (i < avn)
+    {
+        z = arg_types[i]->size;
+        //the argument is a float/double. Handling depends on whether it is variadic, what is the number of args, and if it is a soft float
+        if (arg_types[i]->type == FFI_TYPE_FLOAT || arg_types[i]->type == FFI_TYPE_DOUBLE)
+        {
+           fargp = (fargn >= 8 || (cif->isvariadic && (i > cif->nfixedargs)) || (max_fp_reg_size==0)) ? argp : fpr + fargn;
+           switch (arg_types[i]->type)
+           {
+                case FFI_TYPE_FLOAT:
+                    avaluep[i] = &avalue[i];
+                    avalue[i] = (uintptr_t) *fargp;
+                    break;
+
+                case FFI_TYPE_DOUBLE:
+                    avaluep[i] = &avalue[i];
+                    avalue[i] = (uintptr_t) *fargp;
+                    break;
+           }
+        }
+        //long doubles are handled according to the integer convention
+        else if (arg_types[i]->type == FFI_TYPE_LONGDOUBLE)
+        {
+            if ((uintptr_t)argp & (arg_types[i]->alignment-1))
+            {
+                argp = (ffi_arg*)FFI_ALIGN(argp, arg_types[i]->alignment);
+            }
+            avaluep[i] = alloca(arg_types[i]->size);
+            memcpy(avaluep[i], argp, arg_types[i]->size);
+        }
+        //handle according to struct or integer convetions
+        else
+        {
+            unsigned type = arg_types[i]->type;
+
+
+            /* The size of a pointer depends on the ABI */
+            if (type == FFI_TYPE_POINTER)
+                type = (cif->abi == FFI_RV64_SINGLE || cif->abi == FFI_RV64_DOUBLE || cif->abi == FFI_RV64_SOFT_FLOAT) ? FFI_TYPE_SINT64 : FFI_TYPE_SINT32;
+
+
+            if (arg_types[i]->alignment > sizeof(ffi_arg) && (arg_types[i]->size <= 2*sizeof(ffi_arg)))
+            {
+                argn = FFI_ALIGN(argn, arg_types[i]->alignment / sizeof(ffi_arg));
+                argp = (void*) FFI_ALIGN(argp, arg_types[i]->alignment / sizeof(ffi_arg));
+            }
+
+
+            switch (type)
+            {
+                case FFI_TYPE_SINT8:
+                    avaluep[i] = &avalue[i];
+                    *(SINT8 *) &avalue[i] = (SINT8) *argp;
+                    break;
+
+                case FFI_TYPE_UINT8:
+                    avaluep[i] = &avalue[i];
+                    *(UINT8 *) &avalue[i] = (UINT8) *argp;
+                    break;
+
+                case FFI_TYPE_SINT16:
+                    avaluep[i] = &avalue[i];
+                    *(SINT16 *) &avalue[i] = (SINT16) *argp;
+                    break;
+
+                case FFI_TYPE_UINT16:
+                    avaluep[i] = &avalue[i];
+                    *(UINT16 *) &avalue[i] = (UINT16) *argp;
+                    break;
+
+                case FFI_TYPE_SINT32:
+                    avaluep[i] = &avalue[i];
+                    *(SINT32 *) &avalue[i] = (SINT32) *argp;
+                    break;
+
+                case FFI_TYPE_UINT32:
+                    avaluep[i] = &avalue[i];
+                    *(UINT32 *) &avalue[i] = (UINT32) *argp;
+                    break;
+
+                case FFI_TYPE_SINT64:
+                    avaluep[i] = &avalue[i];
+                    *(SINT64 *) &avalue[i] = (SINT64) *argp;
+                    break;
+
+                case FFI_TYPE_UINT64:
+                    avaluep[i] = &avalue[i];
+                    *(UINT64 *) &avalue[i] = (UINT64) *argp;
+                    break;
+
+                case FFI_TYPE_STRUCT:
+                    if (argn < 8 && arg_types[i]->size <= 2*sizeof(ffi_arg))
+                    {
+                        /* Allocate space to copy structs that were passed in registers */
+                        avaluep[i] = alloca(arg_types[i]->size);
+                        argn_struct = argn;
+                        copy_struct(avaluep[i], 0, cif->abi, arg_types[i], &argn_struct, &fargn, 0, ar, fpr, max_fp_reg_size);
+                        break;
+                    }
+                    else
+                    {
+                        /* The struct was too big to be passed in registers, so it was passed on the stack
+                           with pointers in the registers. We need to properly pass the pointer AND set
+                           the correct size to increment by! */
+                        avaluep[i] = (void *) *argp;
+                        //z = 1;
+                        z = sizeof(ffi_arg);
+                        argn_struct = argn + FFI_ALIGN(z, sizeof(ffi_arg)) / sizeof(ffi_arg);
+                        break;
+                    }
+
+                /* Else fall through. */
+                default:
+                    avaluep[i] = (char *) argp;
+                    break;
+            }
+        }
+        if ((arg_types[i]->type == FFI_TYPE_FLOAT || arg_types[i]->type == FFI_TYPE_DOUBLE) && !(fargn >= 8 || (cif->isvariadic && (i>cif->nfixedargs) ) || (max_fp_reg_size == 0)))
+        {
+           fargn++;
+        }
+        else if (arg_types[i]->type == FFI_TYPE_STRUCT)
+        {
+            argp += (argn_struct - argn);
+            argn = argn_struct;
+        }
+        else
+        {
+           argn += FFI_ALIGN(z, sizeof(ffi_arg)) / sizeof(ffi_arg);
+           argp += FFI_ALIGN(z, sizeof(ffi_arg)) / sizeof(ffi_arg);
+        }
+        i++;
+    }
+
+    /* Invoke the closure. */
+    (closure->fun) (cif, rvalue, avaluep, closure->user_data);
+    return cif->flags >> (FFI_FLAG_BITS * 8);
+}
+
+#endif /* FFI_CLOSURES */
diff --git a/src/riscv/ffitarget.h b/src/riscv/ffitarget.h
new file mode 100644
index 000000000000..986509b7df87
--- /dev/null
+++ b/src/riscv/ffitarget.h
@@ -0,0 +1,145 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - 2014 Michael Knyszek
+                 2017 Alon Amid
+   Target configuration macros for RISC-V.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#if (_riscv_xlen == 32)
+# error We currently only support RV64.
+#endif
+
+#ifdef __LP64__
+# define FFI_SIZEOF_ARG 8
+#else
+# define FFI_SIZEOF_ARG 4
+#endif
+
+#define FFI_FLAG_BITS 2
+
+#ifndef LIBFFI_ASM
+
+typedef unsigned long ffi_arg;
+typedef   signed long ffi_sarg;
+
+typedef enum ffi_abi {
+  FFI_FIRST_ABI = 0,
+  //FFI_RV32,
+  FFI_RV32_SINGLE,
+  FFI_RV32_DOUBLE,
+  FFI_RV32_SOFT_FLOAT,
+  //FFI_RV64,
+  FFI_RV64_SINGLE,
+  FFI_RV64_DOUBLE,
+  FFI_RV64_SOFT_FLOAT,
+  FFI_LAST_ABI,
+
+#if __riscv_xlen == 64
+   #ifdef __riscv_float_abi_soft
+    FFI_DEFAULT_ABI = FFI_RV64_SOFT_FLOAT
+   #elif  __riscv_float_abi_single
+    FFI_DEFAULT_ABI = FFI_RV64_SINGLE
+   #else
+    FFI_DEFAULT_ABI = FFI_RV64_DOUBLE
+//  #else
+//    FFI_DEFAULT_ABI = FFI_RV64
+  #endif
+#elif __riscv_xlen == 32
+   #ifdef __riscv_float_abi_soft
+    FFI_DEFAULT_ABI = FFI_RV32_SOFT_FLOAT
+   #elif __riscv_float_abi_single
+    FFI_DEFAULT_ABI = FFI_RV32_SINGLE
+   #else
+    FFI_DEFAULT_ABI = FFI_RV32_DOUBLE
+//  #else
+//    FFI_DEFAULT_ABI = FFI_RV32
+  #endif
+#else
+   #error Unknown RISC-V ABI.
+#endif /* __riscv_soft_float */
+} ffi_abi;
+
+#else
+
+#if __riscv_xlen == 64
+  #define REG_S sd
+  #define REG_L ld
+#else
+  #define REG_S sw
+  #define REG_L lw
+#endif
+
+#endif /* LIBFFI_ASM */
+
+#define FFI_ARGS_D FFI_TYPE_DOUBLE
+#define FFI_ARGS_F FFI_TYPE_FLOAT
+#define FFI_ARGS_DD ((FFI_TYPE_DOUBLE << FFI_FLAG_BITS) + FFI_TYPE_DOUBLE)
+#define FFI_ARGS_FF ((FFI_TYPE_FLOAT << FFI_FLAG_BITS) + FFI_TYPE_FLOAT)
+#define FFI_ARGS_FD ((FFI_TYPE_DOUBLE << FFI_FLAG_BITS) + FFI_TYPE_FLOAT)
+#define FFI_ARGS_DF ((FFI_TYPE_FLOAT << FFI_FLAG_BITS) + FFI_TYPE_DOUBLE)
+#define FFI_ARGS_DI ((FFI_TYPE_INT << FFI_FLAG_BITS) + FFI_TYPE_DOUBLE)
+#define FFI_ARGS_FI ((FFI_TYPE_INT << FFI_FLAG_BITS) + FFI_TYPE_FLOAT)
+#define FFI_ARGS_ID ((FFI_TYPE_DOUBLE << FFI_FLAG_BITS) + FFI_TYPE_INT)
+#define FFI_ARGS_IF ((FFI_TYPE_FLOAT << FFI_FLAG_BITS) + FFI_TYPE_INT)
+#define FFI_TYPE_SMALLSTRUCT 1
+#define FFI_TYPE_SMALLSTRUCT2 5
+#define FFI_TYPE_STRUCT_D (FFI_TYPE_STRUCT + (FFI_ARGS_D << 4))
+#define FFI_TYPE_STRUCT_F (FFI_TYPE_STRUCT + (FFI_ARGS_F << 4))
+#define FFI_TYPE_STRUCT_DD (FFI_TYPE_STRUCT + (FFI_ARGS_DD << 4))
+#define FFI_TYPE_STRUCT_FF (FFI_TYPE_STRUCT + (FFI_ARGS_FF << 4))
+#define FFI_TYPE_STRUCT_FD (FFI_TYPE_STRUCT + (FFI_ARGS_FD << 4))
+#define FFI_TYPE_STRUCT_DF (FFI_TYPE_STRUCT + (FFI_ARGS_DF << 4))
+#define FFI_TYPE_STRUCT_DI (FFI_TYPE_STRUCT + (FFI_ARGS_DI << 4))
+#define FFI_TYPE_STRUCT_FI (FFI_TYPE_STRUCT + (FFI_ARGS_FI << 4))
+#define FFI_TYPE_STRUCT_ID (FFI_TYPE_STRUCT + (FFI_ARGS_ID << 4))
+#define FFI_TYPE_STRUCT_IF (FFI_TYPE_STRUCT + (FFI_ARGS_IF << 4))
+#define FFI_TYPE_STRUCT_SMALL (FFI_TYPE_STRUCT + (1 << 4))
+#define FFI_TYPE_STRUCT_SMALL2 (FFI_TYPE_STRUCT + (5 << 4))
+#define FFI_TYPE_STRUCT_D_SOFT (FFI_TYPE_STRUCT_D + 256)
+#define FFI_TYPE_STRUCT_F_SOFT (FFI_TYPE_STRUCT_F + 256)
+#define FFI_TYPE_STRUCT_DD_SOFT (FFI_TYPE_STRUCT_DD + 256)
+#define FFI_TYPE_STRUCT_FF_SOFT (FFI_TYPE_STRUCT_FF + 256)
+#define FFI_TYPE_STRUCT_FD_SOFT (FFI_TYPE_STRUCT_FD + 256)
+#define FFI_TYPE_STRUCT_DF_SOFT (FFI_TYPE_STRUCT_DF + 256)
+#define FFI_TYPE_STRUCT_DI_SOFT (FFI_TYPE_STRUCT_DI + 256)
+#define FFI_TYPE_STRUCT_FI_SOFT (FFI_TYPE_STRUCT_FI + 256)
+#define FFI_TYPE_STRUCT_ID_SOFT (FFI_TYPE_STRUCT_ID + 256)
+#define FFI_TYPE_STRUCT_IF_SOFT (FFI_TYPE_STRUCT_IF + 256)
+#define FFI_TYPE_STRUCT_SOFT 16
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 24
+#define FFI_NATIVE_RAW_API 0
+#define FFI_EXTRA_CIF_FIELDS unsigned rstruct_flag; char isvariadic; int nfixedargs
+#define FFI_TARGET_SPECIFIC_VARIADIC 1
+
+#endif
diff --git a/src/riscv/sysv.S b/src/riscv/sysv.S
new file mode 100644
index 000000000000..b653fb1d8979
--- /dev/null
+++ b/src/riscv/sysv.S
@@ -0,0 +1,903 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2015 Michael Knyszek <mknyszek@berkeley.edu>
+                         2015 Andrew Waterman <waterman@cs.berkeley.edu>
+   Based on MIPS N32/64 port
+
+   RISC-V Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+#define callback a0
+#define ecif     a1
+#define bytes    a2
+#define flags    a3
+#define rvalue   a4
+#define fn       a5
+#define fp       s0
+
+#define FFI_SIZEOF_ARG_X0 (0 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_X0P5 (4)
+#define FFI_SIZEOF_ARG_X1 (1 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_X2 (2 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_X3 (3 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_X4 (4 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_X5 (5 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_X6 (6 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_X7 (7 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_X8 (8 * FFI_SIZEOF_ARG)
+
+#define FFI_SIZEOF_ARG_F0 (0 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_F1 (1 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_F2 (2 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_F3 (3 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_F4 (4 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_F5 (5 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_F6 (6 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_F7 (7 * FFI_SIZEOF_ARG)
+#define FFI_SIZEOF_ARG_F8 (8 * FFI_SIZEOF_ARG)
+
+#define ARG_MASK 65535
+
+#define FFI_FLAG_BITS_X0 (0)
+#define FFI_FLAG_BITS_X1 (1)
+#define FFI_FLAG_BITS_X2 (2)
+#define FFI_FLAG_BITS_X3 (3)
+#define FFI_FLAG_BITS_X4 (4)
+#define FFI_FLAG_BITS_X5 (5)
+#define FFI_FLAG_BITS_X6 (6)
+#define FFI_FLAG_BITS_X7 (7)
+
+#define FFI_FLAG_BITS_F0 (0)
+#define FFI_FLAG_BITS_F1 (1)
+#define FFI_FLAG_BITS_F2 (2)
+#define FFI_FLAG_BITS_F3 (3)
+#define FFI_FLAG_BITS_F4 (4)
+#define FFI_FLAG_BITS_F5 (5)
+#define FFI_FLAG_BITS_F6 (6)
+#define FFI_FLAG_BITS_F7 (7)
+
+# Stack pointer needs to be 16-byte aligned, so frame size is rounded up
+#define SIZEOF_FRAME (6 * FFI_SIZEOF_ARG)
+
+    .text
+    .align  2
+    .globl  ffi_call_asm
+    .type   ffi_call_asm, @function
+ffi_call_asm:
+    .cfi_startproc
+
+    ### Prologue
+
+    # a0 - ffi_prep_args pointer
+    # a1 - extended_cif pointer
+    # a2 - bytes
+    # a3 - flags
+    # a4 - rvalue
+    # a5 - function ptr
+
+    add     sp, sp, -SIZEOF_FRAME   # move stack pointer by frame size
+                                    # must be 16-byte aligned
+
+    # stack ptr points to first argument on stack,
+    # but there should be no arguments on the stack
+
+    .cfi_def_cfa_offset SIZEOF_FRAME
+
+    REG_S   ra,      FFI_SIZEOF_ARG_X5(sp)   # save return address
+    REG_S   fp,      FFI_SIZEOF_ARG_X4(sp)   # save frame pointer
+    REG_S   flags,   FFI_SIZEOF_ARG_X3(sp)   # save flags
+    REG_S   fn,      FFI_SIZEOF_ARG_X2(sp)   # save function pointer
+    REG_S   rvalue,  FFI_SIZEOF_ARG_X1(sp)   # save return value pointer
+
+    .cfi_offset 1, -8
+    .cfi_offset 8, -16
+
+    add     fp, sp, SIZEOF_FRAME     # new frame pointer is old stack pointer
+
+    .cfi_def_cfa 8, 0
+
+    add     t4, callback, zero       # function ptr to prep_args
+
+    # Here we're setting up our argspace and its size
+
+    add     t0, bytes, 15      # make sure it is aligned
+    andi    t0, t0,   -16      # to a 16 byte boundry
+
+thirtytwo:
+    sub     sp, sp, t0 # move the stack pointer to reflect the arg space
+
+    # a0 is the stack with proper arg space allocated
+    add     a0, sp, zero
+
+    # a1 is ecif
+    # a2 is bytes
+    # a3 is flags
+
+    jalr    t4  # call ffi_prep_args
+
+    REG_L   t0, -FFI_SIZEOF_ARG_X3(fp)  # load the flags word
+    srli    t2, t0, 16                 # shift our return type into t2
+
+    li      t1, ARG_MASK
+    and     t0, t0, t1                 # mask out the arg types into t0
+
+    # time to load the arguments for the call
+
+#ifndef __riscv_float_abi_soft
+
+####################
+## SET ARGUMENT 0 ##
+####################
+
+set_arg0_float:
+    srli    t1, t0, FFI_FLAG_BITS_F0 # Shift to get the bits for this argument
+    andi    t1, t1, 1               # Mask out the bits for this argument
+
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg0_double
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa0, t5 # initialize register to Nan
+    flw     fa0, FFI_SIZEOF_ARG_F0(sp) # load argument
+    j       set_arg1_float
+
+set_arg0_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa0, FFI_SIZEOF_ARG_F0(sp)
+
+####################
+## SET ARGUMENT 1 ##
+####################
+
+set_arg1_float:
+    srli    t1, t0, FFI_FLAG_BITS_F1 # Shift to get the bits for this argument
+    andi    t1, t1, 1               # Mask out the bits for this argument
+
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg1_double
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa1, t5 # initialize register to Nan
+    flw     fa1, FFI_SIZEOF_ARG_F1(sp) # load argument
+    j       set_arg2_float
+
+set_arg1_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa1, FFI_SIZEOF_ARG_F1(sp)
+
+####################
+## SET ARGUMENT 2 ##
+####################
+
+set_arg2_float:
+    srli    t1, t0, FFI_FLAG_BITS_F2 # Shift to get the bits for this argument
+    andi    t1, t1, 1               # Mask out the bits for this argument
+
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg2_double
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa2, t5 # initialize register to Nan
+    flw     fa2, FFI_SIZEOF_ARG_F2(sp) # load argument
+    j       set_arg3_float
+
+set_arg2_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa2, FFI_SIZEOF_ARG_F2(sp)
+
+####################
+## SET ARGUMENT 3 ##
+####################
+
+set_arg3_float:
+    srli    t1, t0, FFI_FLAG_BITS_F3 # Shift to get the bits for this argument
+    andi    t1, t1, 1               # Mask out the bits for this argument
+
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg3_double
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa3, t5 # initialize register to Nan
+    flw     fa3, FFI_SIZEOF_ARG_F3(sp) # load argument
+    j       set_arg4_float
+
+set_arg3_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa3, FFI_SIZEOF_ARG_F3(sp)
+
+####################
+## SET ARGUMENT 4 ##
+####################
+
+set_arg4_float:
+    srli    t1, t0, FFI_FLAG_BITS_F4 # Shift to get the bits for this argument
+    andi    t1, t1, 1               # Mask out the bits for this argument
+
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg4_double
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa4, t5 # initialize register to Nan
+    flw     fa4, FFI_SIZEOF_ARG_F4(sp) # load argument
+    j       set_arg5_float
+
+set_arg4_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa4, FFI_SIZEOF_ARG_F4(sp)
+
+####################
+## SET ARGUMENT 5 ##
+####################
+
+set_arg5_float:
+    srli    t1, t0, FFI_FLAG_BITS_F5 # Shift to get the bits for this argument
+    andi    t1, t1, 1               # Mask out the bits for this argument
+
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg5_double
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa5, t5 # initialize register to Nan
+    flw     fa5, FFI_SIZEOF_ARG_F5(sp) # load argument
+    j       set_arg6_float
+
+set_arg5_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa5, FFI_SIZEOF_ARG_F5(sp)
+
+####################
+## SET ARGUMENT 6 ##
+####################
+
+set_arg6_float:
+    srli    t1, t0, FFI_FLAG_BITS_F6 # Shift to get the bits for this argument
+    andi    t1, t1, 1               # Mask out the bits for this argument
+
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg6_double
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa6, t5 # initialize register to Nan
+    flw     fa6, FFI_SIZEOF_ARG_F6(sp) # load argument
+    j       set_arg7_float
+
+set_arg6_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa6, FFI_SIZEOF_ARG_F6(sp)
+
+####################
+## SET ARGUMENT 7 ##
+####################
+
+set_arg7_float:
+    srli    t1, t0, FFI_FLAG_BITS_F7 # Shift to get the bits for this argument
+    andi    t1, t1, 1               # Mask out the bits for this argument
+
+    # when its zero, it means its just a word-sized float
+    bne     t1, zero, set_arg7_double
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa7, t5 # initialize register to Nan
+    flw     fa7, FFI_SIZEOF_ARG_F7(sp) # load argument
+    j       finish_fregs
+
+set_arg7_double:
+    # otherwise it must be a double we're dealing with
+    fld     fa7, FFI_SIZEOF_ARG_F7(sp)
+
+
+
+finish_fregs:
+    add     sp, sp, FFI_SIZEOF_ARG_F8  //move stack pointer to beginning of integer arguments
+#endif
+
+
+set_int_args:
+    srli    t0, t0, 8                  //shift out the integer argument flags
+## START RISCV INTEGER REGISTER LOADING ##
+
+    # In the soft-float case, we have no primitive datatype
+    # that has a size of >8 bytes. Therefore, we can
+    # just load everything quite easily and nicely.
+
+    REG_L   a0, FFI_SIZEOF_ARG_X0(sp) # load argument
+    REG_L   a1, FFI_SIZEOF_ARG_X1(sp) # load argument
+    REG_L   a2, FFI_SIZEOF_ARG_X2(sp) # load argument
+    REG_L   a3, FFI_SIZEOF_ARG_X3(sp) # load argument
+    REG_L   a4, FFI_SIZEOF_ARG_X4(sp) # load argument
+    REG_L   a5, FFI_SIZEOF_ARG_X5(sp) # load argument
+    REG_L   a6, FFI_SIZEOF_ARG_X6(sp) # load argument
+    REG_L   a7, FFI_SIZEOF_ARG_X7(sp) # load argument
+
+
+call_it:
+    # First, we fix the stack pointer to point to the first argument
+    # passed on the stack.
+    add     sp, sp, FFI_SIZEOF_ARG_X8
+
+    # Load the function pointer
+    REG_L   t4, -FFI_SIZEOF_ARG_X4(fp)
+
+    # When the return value pointer is NULL, assume no return value.
+    REG_L   t1, -FFI_SIZEOF_ARG_X5(fp)
+    beq     t1, zero, return_void
+
+    # is the return type an int? if not, jump ahead
+    ori     t3, zero, FFI_TYPE_INT
+    bne     t2, t3,   return_int32
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0, -FFI_SIZEOF_ARG_X5(fp)
+    REG_S   a0, 0(t0)
+    j       epilogue
+
+return_int32:
+    ori     t3, zero, FFI_TYPE_SINT32
+#ifndef __riscv_float_abi_soft
+    bne     t2, t3, return_float
+#else
+    bne     t2, t3, return_struct_d_soft
+#endif
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0, -FFI_SIZEOF_ARG_X5(fp)
+    sw      a0, 0(t0)
+    j       epilogue
+
+#ifndef __riscv_float_abi_soft
+return_float:
+    # is the return type a float? if not, jump ahead
+    ori     t3, zero, FFI_TYPE_FLOAT
+    bne     t2, t3, return_struct_f
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    fsw     fa0, FFI_SIZEOF_ARG_X0(t0)
+    j       epilogue
+
+return_double:
+    # is the return type a double? if not, give up
+    ori     t3, zero, FFI_TYPE_DOUBLE
+    bne     t2, t3, return_longdouble
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    fsd     fa0, FFI_SIZEOF_ARG_X0(t0)
+    j       epilogue
+
+return_longdouble:
+    # is the return type a double? if not, give up
+    ori     t3, zero, FFI_TYPE_LONGDOUBLE
+    bne     t2, t3, return_struct_d
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    REG_S   a0,  FFI_SIZEOF_ARG_X0(t0)
+    REG_S   a1,  FFI_SIZEOF_ARG_X1(t0)
+    j       epilogue
+
+### Handle struct special cases (hard float)
+
+  # Here the struct to return is less than
+  # or equal to 2 pointer-words in size. We
+  # need to specifically handle the floats/doubles.
+
+return_struct_d:
+    # is the return type a struct with a double? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_D
+    bne     t2, t3,   return_struct_d_d
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    fsd     fa0, FFI_SIZEOF_ARG_X0(t0)
+    j       epilogue
+
+return_struct_f:
+    # is the return type a struct with a float? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_F
+    bne     t2, t3,   return_struct_f_f
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    fsw     fa0, FFI_SIZEOF_ARG_X0(t0)
+    j       epilogue
+
+return_struct_d_d:
+    # is the return type a struct with two doubles? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_DD
+    bne     t2, t3,   return_struct_d_f
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    fsd     fa0, FFI_SIZEOF_ARG_X0(t0)
+    fsd     fa1, FFI_SIZEOF_ARG_X1(t0)
+    j       epilogue
+
+return_struct_f_f:
+    # is the return type a struct with two floats? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_FF
+#ifdef __riscv_float_abi_double
+    bne     t2, t3,   return_double
+#else
+    bne     t2, t3,   return_struct_d_d_soft
+#endif
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    fsw     fa0, FFI_SIZEOF_ARG_X0(t0)
+    fsw     fa1, FFI_SIZEOF_ARG_X1(t0)
+    j       epilogue
+
+return_struct_d_f:
+    # is the return type a struct with a double then float? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_DF
+    bne     t2, t3,   return_struct_f_d
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    fsd     fa0, FFI_SIZEOF_ARG_X0(t0)
+    fsw     fa1, FFI_SIZEOF_ARG_X1(t0)
+    j       epilogue
+
+return_struct_f_d:
+    # is the return type a struct with a float then double? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_FD
+    bne     t2, t3,   return_struct_f_i
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    fsw     fa0, FFI_SIZEOF_ARG_X0(t0)
+    fsd     fa1, FFI_SIZEOF_ARG_X1(t0)
+    j       epilogue
+
+
+return_struct_f_i:
+    # is the return type a struct with a float then integer? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_FI
+    bne     t2, t3,   return_struct_d_i
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    fsw     fa0, FFI_SIZEOF_ARG_X0(t0)
+    sw      a0, FFI_SIZEOF_ARG_X0P5(t0)
+    j       epilogue
+
+
+return_struct_d_i:
+    # is the return type a struct with a double then integer? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_DI
+    bne     t2, t3,   return_struct_i_f
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    fsd     fa0, FFI_SIZEOF_ARG_X0(t0)
+    sw      a0, FFI_SIZEOF_ARG_X1(t0)
+    j       epilogue
+
+
+return_struct_i_f:
+    # is the return type a struct with a integer then float? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_IF
+    bne     t2, t3,   return_struct_i_d
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    sw      a0, FFI_SIZEOF_ARG_X0(t0)
+    fsw     fa0, FFI_SIZEOF_ARG_X0P5(t0)
+    j       epilogue
+
+
+return_struct_i_d:
+    # is the return type a struct with a integer then double? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_ID
+    bne     t2, t3,   return_struct_small
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    sw      a0, FFI_SIZEOF_ARG_X0(t0)
+    fsd     fa0, FFI_SIZEOF_ARG_X1(t0)
+    j       epilogue
+#else
+
+### Handle struct special cases (soft float)
+
+  # Here the struct to return is less than
+  # or equal to 2 pointer-words in size. We
+  # need to specifically handle the floats/doubles.
+
+return_struct_d_soft:
+    # is the return type a struct with a double? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_D_SOFT
+    bne     t2, t3,   return_struct_f_soft
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    sd      a0,  FFI_SIZEOF_ARG_X0(t0)
+    j       epilogue
+
+return_struct_f_soft:
+    # is the return type a struct with a float? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_F_SOFT
+    bne     t2, t3,   return_struct_d_d_soft
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    sw      a0,  FFI_SIZEOF_ARG_X0(t0)
+    j       epilogue
+
+return_struct_d_d_soft:
+    # is the return type a struct with two doubles? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_DD_SOFT
+    bne     t2, t3,   return_struct_f_f_soft
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    sd      a0,  FFI_SIZEOF_ARG_X0(t0)
+    sd      a1,  FFI_SIZEOF_ARG_X1(t0)
+    j       epilogue
+
+return_struct_f_f_soft:
+    # is the return type a struct with two floats? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_FF_SOFT
+    bne     t2, t3,   return_struct_d_f_soft
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    sw      a0,  FFI_SIZEOF_ARG_X0(t0)
+    sw      a1,  FFI_SIZEOF_ARG_X1(t0)
+    j       epilogue
+
+return_struct_d_f_soft:
+    # is the return type a struct with a double then float? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_DF_SOFT
+    bne     t2, t3,   return_struct_f_d_soft
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    sd      a0,  FFI_SIZEOF_ARG_X0(t0)
+    sw      a1,  FFI_SIZEOF_ARG_X1(t0)
+    j       epilogue
+
+return_struct_f_d_soft:
+    # is the return type a struct with a float then double? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_FD_SOFT
+    bne     t2, t3,   return_struct_small
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    sw      a0,  FFI_SIZEOF_ARG_X0(t0)
+    sd      a1,  FFI_SIZEOF_ARG_X1(t0)
+    j       epilogue
+
+#endif
+
+### Handle struct special cases (tiny structs)
+
+return_struct_small:
+    # is the return type a struct with a float then double? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_SMALL
+    bne     t2, t3,   return_struct_small2
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    REG_S   a0,  FFI_SIZEOF_ARG_X0(t0)
+    j       epilogue
+
+return_struct_small2:
+    # is the return type a struct with a float then double? if not, give up
+    ori     t3, zero, FFI_TYPE_STRUCT_SMALL2
+    bne     t2, t3,   return_struct
+
+    jalr    t4 # call the function
+
+    # We reload the return pointer because it was in a temp reg and
+    # there was just a function call.
+    REG_L   t0,  -FFI_SIZEOF_ARG_X5(fp)
+    REG_S   a0,  FFI_SIZEOF_ARG_X0(t0)
+    REG_S   a1,  FFI_SIZEOF_ARG_X1(t0)
+    j       epilogue
+
+### Any other struct is returned through memory
+return_struct:
+return_void:
+    jalr    t4 # call the function
+
+epilogue:
+    add     sp, fp, zero               # Fix stack pointer
+    REG_L   fp, -FFI_SIZEOF_ARG_X2(sp)  # Restore frame pointer
+    REG_L   ra, -FFI_SIZEOF_ARG_X1(sp)  # Restore return address
+    jr      ra
+
+    .cfi_endproc
+    .size   ffi_call_asm, .-ffi_call_asm
+
+
+/* ffi_closure_asm. Expects address of the passed-in ffi_closure in t0. */
+
+#define SIZEOF_FRAME2 (20 * FFI_SIZEOF_ARG)
+#define A7_OFF2       (19 * FFI_SIZEOF_ARG)
+#define A6_OFF2       (18 * FFI_SIZEOF_ARG)
+#define A5_OFF2       (17 * FFI_SIZEOF_ARG)
+#define A4_OFF2       (16 * FFI_SIZEOF_ARG)
+#define A3_OFF2       (15 * FFI_SIZEOF_ARG)
+#define A2_OFF2       (14 * FFI_SIZEOF_ARG)
+#define A1_OFF2       (13 * FFI_SIZEOF_ARG)
+#define A0_OFF2       (12 * FFI_SIZEOF_ARG)
+#define FA7_OFF2      (11 * FFI_SIZEOF_ARG)
+#define FA6_OFF2      (10 * FFI_SIZEOF_ARG)
+#define FA5_OFF2      ( 9 * FFI_SIZEOF_ARG)
+#define FA4_OFF2      ( 8 * FFI_SIZEOF_ARG)
+#define FA3_OFF2      ( 7 * FFI_SIZEOF_ARG)
+#define FA2_OFF2      ( 6 * FFI_SIZEOF_ARG)
+#define FA1_OFF2      ( 5 * FFI_SIZEOF_ARG)
+#define FA0_OFF2      ( 4 * FFI_SIZEOF_ARG)
+#define V1_OFF2       ( 3 * FFI_SIZEOF_ARG)
+#define V0_OFF2       ( 2 * FFI_SIZEOF_ARG)
+#define RA_OFF2       ( 1 * FFI_SIZEOF_ARG)
+
+    .align 2
+    .globl ffi_closure_asm
+    .type ffi_closure_asm, @function
+ffi_closure_asm:
+    .cfi_startproc
+
+    addi    sp,  sp, -SIZEOF_FRAME2
+
+    .cfi_def_cfa_offset SIZEOF_FRAME2
+
+    REG_S   ra,  RA_OFF2(sp) # Save return address
+
+    .cfi_offset  1, -19*FFI_SIZEOF_ARG
+    .cfi_def_cfa 2, SIZEOF_FRAME2
+
+    # Store all possible argument registers. If there are more than
+    # fit in registers, then they were stored on the stack.
+    REG_S   a0,  A0_OFF2(sp)
+    REG_S   a1,  A1_OFF2(sp)
+    REG_S   a2,  A2_OFF2(sp)
+    REG_S   a3,  A3_OFF2(sp)
+    REG_S   a4,  A4_OFF2(sp)
+    REG_S   a5,  A5_OFF2(sp)
+    REG_S   a6,  A6_OFF2(sp)
+    REG_S   a7,  A7_OFF2(sp)
+
+#ifdef __riscv_float_abi_double
+    # Store all possible float/double registers.
+    fsd     fa0, FA0_OFF2(sp)
+    fsd     fa1, FA1_OFF2(sp)
+    fsd     fa2, FA2_OFF2(sp)
+    fsd     fa3, FA3_OFF2(sp)
+    fsd     fa4, FA4_OFF2(sp)
+    fsd     fa5, FA5_OFF2(sp)
+    fsd     fa6, FA6_OFF2(sp)
+    fsd     fa7, FA7_OFF2(sp)
+#endif
+
+
+#ifdef __riscv_float_abi_single
+    # Store all possible float registers.
+    fsw     fa0, FA0_OFF2(sp)
+    fsw     fa1, FA1_OFF2(sp)
+    fsw     fa2, FA2_OFF2(sp)
+    fsw     fa3, FA3_OFF2(sp)
+    fsw     fa4, FA4_OFF2(sp)
+    fsw     fa5, FA5_OFF2(sp)
+    fsw     fa6, FA6_OFF2(sp)
+    fsw     fa7, FA7_OFF2(sp)
+#endif
+
+
+    # Call ffi_closure_riscv_inner to do the real work.
+    move    a0, t0 # Pointer to the ffi_closure
+    addi    a1, sp, V0_OFF2
+    addi    a2, sp, A0_OFF2
+    addi    a3, sp, FA0_OFF2
+    call    ffi_closure_riscv_inner
+
+    # Return flags are in a0
+    li      t0, FFI_TYPE_INT
+    bne     a0, t0, cls_retint32
+    REG_L   a0, V0_OFF2(sp)
+    j       cls_epilogue
+
+cls_retint32:
+    li      t0, FFI_TYPE_SINT32
+    bne     a0, t0, cls_retfloat
+    lw      a0, V0_OFF2(sp)
+    j       cls_epilogue
+
+cls_retfloat:
+    li      t0, FFI_TYPE_FLOAT
+    bne     a0, t0, cls_retdouble
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa0, t5 # initialize register to Nan
+    flw     fa0, V0_OFF2(sp)
+    j       cls_epilogue
+
+cls_retdouble:
+    li      t0,  FFI_TYPE_DOUBLE
+    bne     a0,  t0, cls_retlongdouble
+    fld     fa0, V0_OFF2(sp)
+    j       cls_epilogue
+
+cls_retlongdouble:
+    li      t0,  FFI_TYPE_LONGDOUBLE
+    bne     a0,  t0, cls_retstruct_d
+    ld      a0, V0_OFF2(sp)
+    ld      a1, V1_OFF2(sp)
+    j       cls_epilogue
+
+cls_retstruct_d:
+    li      t0,  FFI_TYPE_STRUCT_D
+    bne     a0,  t0, cls_retstruct_f
+    fld     fa0, V0_OFF2(sp)
+    j       cls_epilogue
+
+cls_retstruct_f:
+    li      t0,  FFI_TYPE_STRUCT_F
+    bne     a0,  t0, cls_retstruct_d_d
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa0, t5 # initialize register to Nan
+    flw     fa0, V0_OFF2(sp)
+    j       cls_epilogue
+
+cls_retstruct_d_d:
+    li      t0,  FFI_TYPE_STRUCT_DD
+    bne     a0,  t0, cls_retstruct_f_f
+    fld     fa0, V0_OFF2(sp)
+    fld     fa1, V1_OFF2(sp)
+    j       cls_epilogue
+
+cls_retstruct_f_f:
+    li      t0,  FFI_TYPE_STRUCT_FF
+    bne     a0,  t0, cls_retstruct_d_f
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa0, t5 # initialize register to Nan
+    flw     fa0, V0_OFF2(sp)
+    flw     fa1, V1_OFF2(sp)
+    j       cls_epilogue
+
+cls_retstruct_d_f:
+    li      t0,  FFI_TYPE_STRUCT_DF
+    bne     a0,  t0, cls_retstruct_f_d
+    fld     fa0, V0_OFF2(sp)
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa1, t5 # initialize register to Nan
+    flw     fa1, V1_OFF2(sp)
+    j       cls_epilogue
+
+cls_retstruct_f_d:
+    li      t0,  FFI_TYPE_STRUCT_FD
+    bne     a0,  t0, cls_retstruct_f_i
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa0, t5 # initialize register to Nan
+    flw     fa0, V0_OFF2(sp)
+    fld     fa1, V1_OFF2(sp)
+    j       cls_epilogue
+
+
+cls_retstruct_f_i:
+    li      t0,  FFI_TYPE_STRUCT_FI
+    bne     a0,  t0, cls_retstruct_d_i
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa0, t5 # initialize register to Nan
+    flw     fa0, V0_OFF2(sp)
+    lw      a0, V1_OFF2(sp)
+    j       cls_epilogue
+
+cls_retstruct_d_i:
+    li      t0,  FFI_TYPE_STRUCT_DI
+    bne     a0,  t0, cls_retstruct_i_f
+    fld     fa0, V0_OFF2(sp)
+    lw      a0, V1_OFF2(sp)
+    j       cls_epilogue
+
+cls_retstruct_i_f:
+    li      t0,  FFI_TYPE_STRUCT_IF
+    bne     a0,  t0, cls_retstruct_i_d
+    lw      a0, V0_OFF2(sp)
+    li      t5, 0xffffffffffffffff # initialize register to NaN
+    fcvt.d.l fa0, t5 # initialize register to Nan
+    flw     fa0, V1_OFF2(sp)
+    j       cls_epilogue
+
+cls_retstruct_i_d:
+    li      t0,  FFI_TYPE_STRUCT_ID
+    bne     a0,  t0, cls_retstruct_small2
+    lw      a0, V0_OFF2(sp)
+    fld     fa0, V1_OFF2(sp)
+    j       cls_epilogue
+
+cls_retstruct_small2:
+    REG_L   a0, V0_OFF2(sp)
+    REG_L   a1, V1_OFF2(sp)
+
+# Epilogue
+cls_epilogue:
+    REG_L   ra, RA_OFF2(sp) # Restore return address
+    addi    sp, sp, SIZEOF_FRAME2
+    ret
+
+    .cfi_endproc
+    .size ffi_closure_asm, .-ffi_closure_asm
